/**************************************************************************
  Seeed studio XIAO ESP32C3
  BNO085 UART-RVC + OTA + WebSocket + Event-Window Logging + Live Plot

  - HTTP (port 80): serves the web UI with a canvas plot and checkboxes
  - WebSocket (port 81): real-time JSON stream + control/events
  - On "catch/miss/other" event:
      * Take a snapshot of the last PRE_WINDOW_MS of IMU data from RAM
      * Write that window to a new CSV
      * Append an event row
      * Close file and reset segment metrics
 **************************************************************************/

#include <WiFi.h>
#include <ArduinoOTA.h>
#include <Adafruit_BNO08x_RVC.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <LittleFS.h>
#include "secrets.h"
#include <Adafruit_NeoPixel.h>

// ---------- Pins ----------
#define BNO_RX_PIN    20   // XIAO ESP32C3 RX header (wired to BNO085 SDA / sensor TX)
#define BNO_TX_PIN    -1   // unused in RVC
#define LED_DATA_PIN   5   // XIAO D3 = GPIO5

// ---------- LEDs ----------
#define NUM_LEDS 2
Adafruit_NeoPixel pixels(
  NUM_LEDS,
  LED_DATA_PIN,
  NEO_GRB + NEO_KHZ800
);

// ---------- Feature toggles ----------
#define ENABLE_LOGGING    1    // 0: disable file writes, 1: enable event-window logging
#define DIAG_TIMING       0    // 1: print timing deltas on Serial (adds jitter)
#define FORCE_FORMAT_FS   1    // 1: format LittleFS on boot (use once to clear old logs, then set back to 0)

// ---------- Globals ----------
Adafruit_BNO08x_RVC rvc;

WebServer         http(80);
WebSocketsServer  ws(81);                 // ws://<ip>:81
File              logFile;
char              currentLogName[48] = "";

// Sequence counter for each streamed sample
volatile uint32_t seqNo = 0;

// time helpers
static inline uint32_t dev_now_ms() { return millis(); }
static inline uint32_t dev_now_us() { return micros(); }

// ---------- Ring buffer for pre-event logging (RAM only) ----------
// We want a ~30s pre-event window.
// At ~100 Hz, that is ~3000 samples. These are related but not identical:
// PRE_WINDOW_MS is a time window; RING_CAP is the max number of samples we store.
const uint32_t PRE_WINDOW_MS = 30000;  // 30 seconds of history
const size_t   RING_CAP      = 3000;   // max samples in ring
uint32_t sessionStartMs = 0; // timestamp when we hit New Session button

struct ImuSample {
  uint32_t t_ms;
  float yaw, pitch, roll;
  float ax, ay, az;
};

ImuSample ringBuf[RING_CAP];
size_t    ringHead      = 0;   // next write index
bool      ringFilled    = false;

// Segment / health metrics (reset per segment/event)
uint32_t segSamples      = 0;
uint32_t segStartMs      = 0;
uint32_t imuGapCount     = 0;
uint32_t imuGapMaxMs     = 0;
float    imuAvgPeriodMs  = 0.0f;
uint32_t lastImuMs       = 0;

void resetSegmentMetrics() {
  segSamples     = 0;
  segStartMs     = 0;
  imuGapCount    = 0;
  imuGapMaxMs    = 0;
  imuAvgPeriodMs = 0.0f;
  lastImuMs      = 0;
}

// ---------- HTML UI (served from flash) ----------
const char PAGE_INDEX[] PROGMEM = R"HTML(
<!doctype html>
<meta charset="utf-8">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>IMU Plot</title>
<style>
  :root{--fg:#111;--muted:#666;--bg:#fff}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg);margin:16px}
  h2{margin:8px 0 6px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:6px 0}
  button{padding:8px 12px;border:1px solid #ccc;border-radius:10px;background:#f6f6f6;cursor:pointer}
  button:active{transform:translateY(1px)}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #ccc;border-radius:999px;color:#333}
  #legend{display:flex;gap:10px;flex-wrap:wrap}
  .lg{display:flex;align-items:center;gap:6px;font-size:13px}
  .sw{width:16px;height:16px;border-radius:4px;border:1px solid #aaa;display:inline-block}
  .muted{color:var(--muted)}
  #canvas{display:block;width:100%;max-width:980px;height:420px;border:1px solid #eee;border-radius:12px;background:#fff}
  .chk{margin-right:10px}
  label{user-select:none}
</style>

<h2>IMU Live Plot</h2>

<div class="row">
  <span>IP: <b id=ip></b></span>
  <span id=net class=pill>Syncing clock…</span>
  <span id=stats class=pill>rtt=– ms</span>
  <span id=offset class=pill>offset=– ms</span>
</div>

<canvas id="canvas" width="1200" height="460"></canvas>

<div class="row" id="legend">
  <!-- toggles generated by JS -->
</div>

<div class="row">
  <label class="chk"><input type="checkbox" id="autoscale"> Autoscale</label>
  <button id="pauseBtn">Pause</button>
  <a href="/download"><button>Download CSV</button></a>
  <button id="rotateBtn">New Session</button>
  <button id="catchBtn">Catch</button>
  <button id="missBtn">Miss</button>
  <button id="otherBtn">Other…</button>
</div>

<div class="row muted" style="font-size:13px">
  <div>Accel Z: m/s^2 (±40 default)</div>
</div>

<script>
const ipEl = document.getElementById('ip');
const netEl = document.getElementById('net');
const rttEl = document.getElementById('stats');
const offEl = document.getElementById('offset');
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
ipEl.textContent = location.host;

let ws;

// Series config: ONLY az for now
const series = [
  { key:'az',    color:'#f4511e', enabled:true,  kind:'acc' },
];

const BUFFER = 1200;     // ring buffer for plotting (host-side only)
const data = {};
series.forEach(s => data[s.key] = new Array(BUFFER).fill(null));
data.t = new Array(BUFFER).fill(null);
let head = 0;
let paused = false;

// Ranges
const FIXED = { acc:[-40,40] };
const autoscaleEl = document.getElementById('autoscale');

// UI legend + checkboxes
const legend = document.getElementById('legend');
series.forEach((s, i) => {
  const id = 'chk_'+s.key;
  const wrap = document.createElement('label');
  wrap.className = 'lg';
  wrap.innerHTML = `<input type="checkbox" id="${id}" ${s.enabled?'checked':''}>
                    <span class="sw" style="background:${s.color}"></span>${s.key}`;
  legend.appendChild(wrap);
  document.getElementById(id).addEventListener('change', (e)=>{
    s.enabled = e.target.checked;
  });
});

// Buttons
document.getElementById('pauseBtn').onclick = ()=>{
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
};
document.getElementById('rotateBtn').onclick = ()=> ws.send(JSON.stringify({ type:'rotate' }));
document.getElementById('catchBtn').onclick  = ()=> ws.send(JSON.stringify({ type:'event', kind:'catch', note:'', t: Date.now() }));
document.getElementById('missBtn').onclick   = ()=> ws.send(JSON.stringify({ type:'event', kind:'miss',  note:'', t: Date.now() }));
document.getElementById('otherBtn').onclick  = ()=>{
  const note = prompt('Describe event:') || '';
  ws.send(JSON.stringify({ type:'event', kind:'other', note, t: Date.now() }));
};

// Time sync (Cristian) with EWMA
const nowMs = ()=> performance.now();
function makeEWMA(a){ let v=0, has=false; return {u(x){v=has?(a*x+(1-a)*v):x;has=true;return v},g(){return v},ok(){return has}};}
const rttE = makeEWMA(0.3);
const offE = makeEWMA(0.2);

async function syncClock(samples=8, timeout=500){
  return new Promise((resolve)=>{
    let done=0, rs=[];
    function once(){
      const t0 = nowMs();
      ws.send(JSON.stringify({ type:'sync', t0 }));
      const to = setTimeout(()=>{ if(++done>=samples) finish(); else once(); }, timeout);
      const onMsg = (ev)=>{
        let d; try{ d=JSON.parse(ev.data); }catch{ return; }
        if (d.type!=='sync') return;
        ws.removeEventListener('message', onMsg);
        clearTimeout(to);
        const tA = nowMs(), t1 = d.t1_ms;
        rs.push({ rtt:(tA-t0), off:((t0+tA)/2 - t1) });
        if(++done>=samples) finish(); else once();
      };
      ws.addEventListener('message', onMsg);
    }
    function finish(){
      rs.sort((a,b)=>a.rtt-b.rtt);
      const keep = rs.slice(0, Math.max(1, Math.floor(rs.length/2)));
      const offs = keep.map(x=>x.off).sort((a,b)=>a-b);
      const med  = offs[Math.floor(offs.length/2)];
      rttE.u(keep[0].rtt); offE.u(med);
      rttEl.textContent = `rtt=${rttE.g().toFixed(1)} ms`;
      offEl.textContent = `offset=${offE.g().toFixed(1)} ms`;
      netEl.textContent = `Clock synced (${keep.length}/${rs.length})`;
      resolve();
    }
    once();
  });
}

// WebSocket
function openWS() {
  ws = new WebSocket('ws://' + location.hostname + ':81');

  ws.onopen = async () => {
    netEl.textContent = 'Syncing clock…';
    await syncClock(8);
  };

  let lastSeq  = null;
  let lastDevT = null; // last device timestamp (ms)
  let lastHost = null; // last browser timestamp (ms, performance.now)

  ws.onmessage = (ev) => {
    let d;
    try {
      d = JSON.parse(ev.data);
    } catch {
      return;
    }

    if (d.type === 'ack' || d.type === 'sync') return;
    if (paused) return;

    const hostNow = performance.now();

    if (lastSeq !== null && d.seq !== undefined && d.t !== undefined) {
      const dSeq  = d.seq - lastSeq;
      const dDev  = d.t   - lastDevT;    // ms between device timestamps
      const dHost = hostNow - lastHost;  // ms between arrivals in browser

      // Host jitter check (for debugging streaming health)
      if (dHost > 150) {  // raise threshold; only log truly big stalls
        console.log(
          'BIG HOST GAP',
          dSeq, 'samples,',
          dHost.toFixed(1), 'ms',
          ev.target.url
        );
      }
      // Device-side spacing is monitored on the ESP already
    }

    lastSeq  = d.seq;
    lastDevT = d.t;
    lastHost = hostNow;

    // push into ring buffer for plotting (az only)
    data.t[head]  = d.t;
    data.az[head] = ('az' in d) ? d.az : null;
    head = (head + 1) % BUFFER;
  };

  ws.onclose = () => setTimeout(openWS, 800);
}

openWS();

// Plotting
function getRange(kind){
  if (!autoscaleEl.checked) return FIXED[kind];
  // autoscale over visible buffer for enabled series of this kind
  let lo= Infinity, hi= -Infinity;
  series.forEach(s=>{
    if (s.kind!==kind || !s.enabled) return;
    const arr = data[s.key];
    for (let i=0;i<BUFFER;i++){
      const v = arr[i];
      if (v==null) continue;
      if (v<lo) lo=v; if (v>hi) hi=v;
    }
  });
  if (lo===Infinity) return FIXED[kind];
  if (lo===hi){ lo-=1; hi+=1; }
  // add 10% headroom
  const pad = (hi-lo)*0.1;
  return [lo-pad, hi+pad];
}

function drawGrid(x, y, w, h, ylo, yhi, label){
  ctx.save();
  ctx.translate(x,y);
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  // axes
  for (let i=0;i<=5;i++){
    const yy = h*i/5;
    ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke();
  }
  ctx.fillStyle = '#999';
  ctx.font = '12px ui-monospace,monospace';
  ctx.fillText(`${label} [${ylo.toFixed(1)}..${yhi.toFixed(1)}]`, 8, 14);
  ctx.restore();
}

function mapY(val, ylo, yhi, y, h){
  const t = (val - ylo)/(yhi - ylo);
  return y + (1 - t)*h;
}

function drawSeries(arr, color, x, y, w, h, ylo, yhi){
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  // iterate in time order: head..end, then 0..head-1
  let drew=false;
  const step = w / (BUFFER-1);
  let idx = head, px = x, first = true;
  for (let i=0;i<BUFFER;i++){
    const v = arr[idx];
    const py = (v==null) ? null : mapY(v, ylo, yhi, y, h);
    if (py!=null){
      if (first){ ctx.moveTo(px, py); first=false; }
      else ctx.lineTo(px, py);
      drew = true;
    } else {
      // lift pen on gaps
      first = true;
    }
    px += step;
    idx = (idx+1) % BUFFER;
  }
  if (drew) ctx.stroke();
}

function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);

  const pad = 12;
  const w = cvs.width - pad*2;
  const h = cvs.height - pad*2;

  // Single panel: accel Z
  const [accLo,accHi] = getRange('acc');
  drawGrid(pad, pad, w, h, accLo, accHi, 'az (m/s^2)');
  series.filter(s=>s.kind==='acc' && s.enabled).forEach(s=>{
    drawSeries(data[s.key], s.color, pad, pad, w, h, accLo, accHi);
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
)HTML";

// ---------- Wi-Fi / OTA ----------
static void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(SECRET_WIFI_SSID, SECRET_WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(200); Serial.print("."); }
  Serial.print("\nWiFi: "); Serial.println(WiFi.localIP());
}

static void setupOTA() {
  ArduinoOTA.setHostname(SECRET_OTA_HOSTNAME);
  if (SECRET_OTA_PASS_HASH && strlen(SECRET_OTA_PASS_HASH)==64) {
    ArduinoOTA.setPasswordHash(SECRET_OTA_PASS_HASH);
  }
  ArduinoOTA.begin();
  Serial.println("OTA ready");
}

// ---------- Logging helpers ----------
void openLog(const char* name) {
  if (logFile) {
    logFile.close();
  }

  strncpy(currentLogName, name, sizeof(currentLogName));
  currentLogName[sizeof(currentLogName) - 1] = '\0';

  logFile = LittleFS.open(currentLogName, FILE_WRITE);
  if (logFile && logFile.size()==0) {
    logFile.println("t_ms,yaw,pitch,roll,ax,ay,az,event,note");
  }
}

void rotateLog() {
  static uint16_t idx = 1;
  char buf[48];
  snprintf(buf, sizeof(buf), "/imu_log_%u.csv", idx++);
  openLog(buf);
  Serial.printf("New segment: %s\n", buf);
}

// ---------- HTTP ----------
void handleRoot() {
  http.setContentLength(strlen_P(PAGE_INDEX));
  http.sendHeader("Content-Type", "text/html; charset=utf-8");
  http.send(200, "text/html", "");
  http.sendContent_P(PAGE_INDEX);
}

void handleDownload() {
  if (!currentLogName[0] || !LittleFS.exists(currentLogName)) {
    http.send(404, "text/plain", "log not found");
    return;
  }
  File f = LittleFS.open(currentLogName, FILE_READ);
  http.streamFile(f, "text/csv");
  f.close();
}

// ---------- WebSocket ----------
void wsEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t len) {
  if (type == WStype_TEXT) {
    String msg((char*)payload, len);

    // time sync request
    if (msg.indexOf("\"type\":\"sync\"") >= 0) {
      double t0 = 0;
      int k = msg.indexOf("\"t0\":");
      if (k >= 0) {
        int s = k + 5;
        int e = msg.indexOf(",", s);
        if (e < 0) e = msg.indexOf("}", s);
        if (e > s) t0 = msg.substring(s, e).toDouble();
      }
      char js[96];
      snprintf(js, sizeof(js), "{\"type\":\"sync\",\"t0\":%.3f,\"t1_ms\":%lu}",
               t0, (unsigned long)dev_now_ms());
      ws.sendTXT(num, js);
      return;
    }

    // "New Session" from UI: clear history + reset metrics + (optionally) delete current log
    if (msg.indexOf("\"type\":\"rotate\"") >= 0) {
      sessionStartMs = dev_now_ms();  // mark start of new session

      // Clear RAM ring buffer
      ringHead   = 0;
      ringFilled = false;

      // Reset per-segment metrics
      resetSegmentMetrics();

      #if ENABLE_LOGGING
        // Optional: delete the last CSV to keep FS clean once you've downloaded it
        if (currentLogName[0] && LittleFS.exists(currentLogName)) {
          LittleFS.remove(currentLogName);
        }
        currentLogName[0] = '\0';
      #endif

        ws.sendTXT(num, "{\"type\":\"ack\",\"cmd\":\"rotate\"}");
        return;
    }

    // event with optional note (flush pre-window from ring buffer to CSV)
    String kind = "", note = "";
    int k2 = msg.indexOf("\"kind\":\"");
    if (k2 >= 0) {
      int s = k2 + 8;
      int e = msg.indexOf("\"", s);
      if (e > s) kind = msg.substring(s, e);
    }
    int n = msg.indexOf("\"note\":\"");
    if (n >= 0) {
      int s = n + 8;
      int e = msg.indexOf("\"", s);
      if (e > s) {
        note = msg.substring(s, e);
        note.replace(",", " ");  // keep CSV clean
      }
    }

  uint32_t t_event = dev_now_ms();


  #if ENABLE_LOGGING
      // Create a new segment file for this event
      rotateLog();  // sets currentLogName and opens logFile

      if (logFile) {
        // Base: 30s window
        const uint32_t baseStart =
          (t_event > PRE_WINDOW_MS) ? (t_event - PRE_WINDOW_MS) : 0;

        // Don't include samples from before the current sesion
        const uint32_t windowStart = 
          (sessionStartMs > baseStart) ? sessionStartMs : baseStart;

        size_t count = ringFilled ? RING_CAP : ringHead;
        size_t idx = ringFilled ? ringHead : 0; // oldest

        for (size_t i = 0; i < count; ++i) {
          const ImuSample &s = ringBuf[idx];

          // Only keep samples in [windowStart, t_event]
          if (s.t_ms >= windowStart && s.t_ms <= t_event) {
            logFile.printf(
              "%lu,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,,\n",
              (unsigned long)s.t_ms,
              s.yaw, s.pitch, s.roll,
              s.ax, s.ay, s.az
            );
          }

          idx = (idx + 1) % RING_CAP;
        }

        // Append the event row itself
        logFile.printf(
          "%lu,,,,,,,%s,%s\n",
          (unsigned long)t_event,
          kind.c_str(),
          note.c_str()
        );

        logFile.flush();
        logFile.close();
      }
  #endif

      // Reset metrics for the next segment
      resetSegmentMetrics();

      ws.sendTXT(num, "{\"type\":\"ack\",\"cmd\":\"event\"}");
    }
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);
  delay(100);

  Serial.print("Reset reason: ");
  Serial.println(esp_reset_reason());
  Serial.print("Free heap: ");
  Serial.println(ESP.getFreeHeap());

  // ---------- LittleFS init / optional format ---------- 
    if (!LittleFS.begin()) {
      Serial.println("LittleFS mount failed, trying to format...");
      if (LittleFS.format()) {
        Serial.println("LittleFS format OK, remounting...");
        if (!LittleFS.begin()) {
          Serial.println("LittleFS remount failed after format!");
        }
      } else {
        Serial.println("LittleFS format FAILED!");
      }
    } else {
      Serial.println("LittleFS mounted OK.");
    }

    #if FORCE_FORMAT_FS
      Serial.println("FORCE_FORMAT_FS=1 → formatting LittleFS...");
      if (LittleFS.format()) {
        Serial.println("Forced format OK, remounting LittleFS...");
        if (!LittleFS.begin()) {
          Serial.println("LittleFS remount failed after forced format!");
        }
      } else {
        Serial.println("Forced LittleFS format FAILED!");
      }
    #endif

    // Print FS stats so we know how big the partition actually is
    if (LittleFS.begin()) {
      size_t total = LittleFS.totalBytes();
      size_t used  = LittleFS.usedBytes();
      size_t freeB = (total > used) ? (total - used) : 0;
      Serial.printf("LittleFS: total=%u bytes, used=%u, free=%u\n",
                    (unsigned)total, (unsigned)used, (unsigned)freeB);
    } else {
      Serial.println("LittleFS still not mounted, logging disabled.");
    }

  currentLogName[0] = '\0';
  resetSegmentMetrics();

  // Start initial session at boot
  sessionStartMs = dev_now_ms();


  WiFi.onEvent([](WiFiEvent_t event, WiFiEventInfo_t info){
    if (event == ARDUINO_EVENT_WIFI_STA_DISCONNECTED) {
      Serial.print("WiFi DISCONNECTED, reason=");
      Serial.println(info.wifi_sta_disconnected.reason);
    }
    if (event == ARDUINO_EVENT_WIFI_STA_GOT_IP) {
      Serial.print("WiFi GOT IP: ");
      Serial.println(WiFi.localIP());
    }
  });

  connectWiFi();
  setupOTA();

  // BNO085 one-wire UART
  Serial1.begin(115200, SERIAL_8N1, BNO_RX_PIN, BNO_TX_PIN);
  if (!rvc.begin(&Serial1)) Serial.println("BNO085 RVC init failed!");
  else Serial.println("BNO085 RVC ready.");

  // HTTP + WS
  http.on("/", handleRoot);
  http.on("/download", handleDownload);
  http.begin();

  ws.begin();
  ws.onEvent(wsEvent);

  Serial.println("Open http://<ESP-IP>/ in your phone browser");
  Serial.println("WebSocket port: 81");

  pixels.begin();
  pixels.setBrightness(100);   // keep 0-255, keep <120 for LiPo to prevent voltage sag/brownout
  pixels.clear();
  // pixels.show();
}

// ---------- Loop ----------
void loop() {
  // temp IP check
  static uint32_t lastIpPrint = 0;

  if (millis() - lastIpPrint > 5000) {
    lastIpPrint = millis();
    Serial.print("IP: ");
    Serial.print(WiFi.localIP());
    Serial.print(" | Status: ");
    Serial.println((int)WiFi.status()); // 3 = WL_CONNECTED
  }
  // end IP check

  // temp LED check
  static uint32_t lastUpdate = 0;
  static uint8_t  hue        = 0;

  if (millis() - lastUpdate > 10) {
    lastUpdate = millis();
    hue++;

    uint32_t c1 = pixels.ColorHSV(hue * 256,        255, 255);
    uint32_t c2 = pixels.ColorHSV((hue + 85) * 256, 255, 255);

    pixels.setPixelColor(0, c1);
    pixels.setPixelColor(1, c2);
    pixels.clear(); // delete me?
    // pixels.show();
  }
  // end LED check

#if DIAG_TIMING
  static uint32_t lastReadMicros = 0;
  static uint32_t lastSendMicros = 0;
  uint32_t now_us = dev_now_us();
  Serial.printf("DeltaRead_us=%lu DeltaSend_us=%lu\n",
                now_us - lastReadMicros, now_us - lastSendMicros);
  lastReadMicros = now_us;
#endif

  ArduinoOTA.handle();
  http.handleClient();
  ws.loop();

  // Read IMU → update ring buffer + stream
  static uint32_t lastSend = 0;   // WS throttle

  BNO08x_RVC_Data d;
  if (rvc.read(&d)) {
    const uint32_t tr_us = dev_now_us();   // device time at read (us)
    const uint32_t t_ms  = dev_now_ms();   // device time at read (ms)

    // IMU gap + metrics
    if (lastImuMs != 0) {                  // skip very first sample
      uint32_t dt = t_ms - lastImuMs;
      if (dt > 15) {
        Serial.printf("IMU GAP %lu ms\n", (unsigned long)dt);
        imuGapCount++;
      }
      if (dt > imuGapMaxMs) imuGapMaxMs = dt;

      float fdt = (float)dt;
      if (imuAvgPeriodMs == 0.0f) imuAvgPeriodMs = fdt;
      else                        imuAvgPeriodMs = 0.1f * fdt + 0.9f * imuAvgPeriodMs;
    } else {
      // first sample of this segment
      segStartMs = t_ms;
    }
    lastImuMs = t_ms;
    segSamples++;

    // ---------- Ring buffer update (RAM only, no flash writes here) ----------
    ImuSample &s = ringBuf[ringHead];
    s.t_ms  = t_ms;
    s.yaw   = d.yaw;
    s.pitch = d.pitch;
    s.roll  = d.roll;
    s.ax    = d.x_accel;
    s.ay    = d.y_accel;
    s.az    = d.z_accel;

    ringHead = (ringHead + 1) % RING_CAP;
    if (ringHead == 0) ringFilled = true;
    // ---------- end ring buffer update ----------

    // --- throttle WS to ~15 Hz (lighter streaming) ---
    if (t_ms - lastSend >= 67) {  // 67 ms ≈ 15 fps
      lastSend = t_ms;

      const uint32_t ts_us   = dev_now_us();
      const uint32_t thisSeq = ++seqNo;

      // Slimmed JSON: only az + timing
      char js[128];
      snprintf(js, sizeof(js),
        "{\"type\":\"data\",\"seq\":%lu,\"t\":%lu,\"tr_us\":%lu,\"ts_us\":%lu,"
        "\"az\":%.3f}",
        (unsigned long)thisSeq,
        (unsigned long)t_ms,
        (unsigned long)tr_us,
        (unsigned long)ts_us,
        d.z_accel
      );

      ws.broadcastTXT(js);
    }
  }
}
