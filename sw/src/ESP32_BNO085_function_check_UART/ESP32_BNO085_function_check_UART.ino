/**************************************************************************
  Seeed studio XIAO ESP32C3
  BNO085 UART-RVC + OTA + WebSocket + CSV logging + Live Plot

  - HTTP (port 80): serves the web UI with a canvas plot and checkboxes
  - WebSocket (port 81): real-time JSON stream + control events
  - CSV available at http://<esp-ip>/download
 **************************************************************************/

#include <WiFi.h>
#include <ArduinoOTA.h>
#include <Adafruit_BNO08x_RVC.h>
#include <WebServer.h>
#include <WebSocketsServer.h>
#include <LittleFS.h>
#include "secrets.h"

// ---------- Pins ----------
#define BNO_RX_PIN 20   // XIAO ESP32C3 RX header (wired to BNO085 SDA / sensor TX)
#define BNO_TX_PIN -1   // unused in RVC

// ---------- Feature toggles ----------
#define ENABLE_LOGGING 0    // 0: disable all file writes for testing
#define DIAG_TIMING    0    // 1: print timing deltas on Serial (adds jitter)

// ---------- Globals ----------
Adafruit_BNO08x_RVC rvc;

WebServer         http(80);
WebSocketsServer  ws(81);                 // ws://<ip>:81
File              logFile;
char              currentLogName[48] = "/imu_log.csv";

// const uint8_t LED_BRIGHT = 16;
uint32_t lastReadMicros = 0;
uint32_t lastSendMicros = 0;
volatile uint32_t seqNo = 0;              // sequence counter for each streamed sample

// time helpers
static inline uint32_t dev_now_ms() { return millis(); }
static inline uint32_t dev_now_us() { return micros(); }

// ---------- HTML UI (served from flash) ----------
const char PAGE_INDEX[] PROGMEM = R"HTML(
<!doctype html>
<meta charset="utf-8">
<meta name=viewport content="width=device-width,initial-scale=1">
<title>IMU Plot</title>
<style>
  :root{--fg:#111;--muted:#666;--bg:#fff}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg);margin:16px}
  h2{margin:8px 0 6px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:6px 0}
  button{padding:8px 12px;border:1px solid #ccc;border-radius:10px;background:#f6f6f6;cursor:pointer}
  button:active{transform:translateY(1px)}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #ccc;border-radius:999px;color:#333}
  #legend{display:flex;gap:10px;flex-wrap:wrap}
  .lg{display:flex;align-items:center;gap:6px;font-size:13px}
  .sw{width:16px;height:16px;border-radius:4px;border:1px solid #aaa;display:inline-block}
  .muted{color:var(--muted)}
  #canvas{display:block;width:100%;max-width:980px;height:420px;border:1px solid #eee;border-radius:12px;background:#fff}
  .chk{margin-right:10px}
  label{user-select:none}
</style>

<h2>IMU Live Plot</h2>

<div class="row">
  <span>IP: <b id=ip></b></span>
  <span id=net class=pill>Syncing clock…</span>
  <span id=stats class=pill>rtt=– ms</span>
  <span id=offset class=pill>offset=– ms</span>
</div>

<canvas id="canvas" width="1200" height="460"></canvas>

<div class="row" id="legend">
  <!-- toggles generated by JS -->
</div>

<div class="row">
  <label class="chk"><input type="checkbox" id="autoscale"> Autoscale</label>
  <button id="pauseBtn">Pause</button>
  <a href="/download"><button>Download CSV</button></a>
  <button id="rotateBtn">New Session</button>
  <button id="catchBtn">Catch</button>
  <button id="missBtn">Miss</button>
  <button id="otherBtn">Other…</button>
</div>

<div class="row muted" style="font-size:13px">
  <div>Angles: deg (±180 default)</div>
  <div>Accel: m/s^2 (±40 default)</div>
</div>

<script>
const ipEl = document.getElementById('ip');
const netEl = document.getElementById('net');
const rttEl = document.getElementById('stats');
const offEl = document.getElementById('offset');
const cvs = document.getElementById('canvas');
const ctx = cvs.getContext('2d');
ipEl.textContent = location.host;

let ws;

// Series config
const series = [
  { key:'yaw',   color:'#d81b60', enabled:false, kind:'ang' },
  { key:'pitch', color:'#8e24aa', enabled:false, kind:'ang' },
  { key:'roll',  color:'#3949ab', enabled:true,  kind:'ang' },
  { key:'ax',    color:'#1e88e5', enabled:true,  kind:'acc' },
  { key:'ay',    color:'#43a047', enabled:true,  kind:'acc' },
  { key:'az',    color:'#f4511e', enabled:true,  kind:'acc' },
];

const BUFFER = 1200;     // ~20s at 60Hz
const data = {};
series.forEach(s => data[s.key] = new Array(BUFFER).fill(null));
let head = 0;
let paused = false;

// Ranges
const FIXED = { ang:[-180,180], acc:[-40,40] };
const autoscaleEl = document.getElementById('autoscale');

// UI legend + checkboxes
const legend = document.getElementById('legend');
series.forEach((s, i) => {
  const id = 'chk_'+s.key;
  const wrap = document.createElement('label');
  wrap.className = 'lg';
  wrap.innerHTML = `<input type="checkbox" id="${id}" ${s.enabled?'checked':''}>
                    <span class="sw" style="background:${s.color}"></span>${s.key}`;
  legend.appendChild(wrap);
  document.getElementById(id).addEventListener('change', (e)=>{
    s.enabled = e.target.checked;
  });
});

// Buttons
document.getElementById('pauseBtn').onclick = ()=>{
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
};
document.getElementById('rotateBtn').onclick = ()=> ws.send(JSON.stringify({ type:'rotate' }));
document.getElementById('catchBtn').onclick  = ()=> ws.send(JSON.stringify({ type:'event', kind:'catch', note:'', t: Date.now() }));
document.getElementById('missBtn').onclick   = ()=> ws.send(JSON.stringify({ type:'event', kind:'miss',  note:'', t: Date.now() }));
document.getElementById('otherBtn').onclick  = ()=>{
  const note = prompt('Describe event:') || '';
  ws.send(JSON.stringify({ type:'event', kind:'other', note, t: Date.now() }));
};

// Time sync (Cristian) with EWMA
const nowMs = ()=> performance.now();
function makeEWMA(a){ let v=0, has=false; return {u(x){v=has?(a*x+(1-a)*v):x;has=true;return v},g(){return v},ok(){return has}};}
const rttE = makeEWMA(0.3);
const offE = makeEWMA(0.2);

async function syncClock(samples=8, timeout=500){
  return new Promise((resolve)=>{
    let done=0, rs=[];
    function once(){
      const t0 = nowMs();
      ws.send(JSON.stringify({ type:'sync', t0 }));
      const to = setTimeout(()=>{ if(++done>=samples) finish(); else once(); }, timeout);
      const onMsg = (ev)=>{
        let d; try{ d=JSON.parse(ev.data); }catch{ return; }
        if (d.type!=='sync') return;
        ws.removeEventListener('message', onMsg);
        clearTimeout(to);
        const tA = nowMs(), t1 = d.t1_ms;
        rs.push({ rtt:(tA-t0), off:((t0+tA)/2 - t1) });
        if(++done>=samples) finish(); else once();
      };
      ws.addEventListener('message', onMsg);
    }
    function finish(){
      rs.sort((a,b)=>a.rtt-b.rtt);
      const keep = rs.slice(0, Math.max(1, Math.floor(rs.length/2)));
      const offs = keep.map(x=>x.off).sort((a,b)=>a-b);
      const med  = offs[Math.floor(offs.length/2)];
      rttE.u(keep[0].rtt); offE.u(med);
      rttEl.textContent = `rtt=${rttE.g().toFixed(1)} ms`;
      offEl.textContent = `offset=${offE.g().toFixed(1)} ms`;
      netEl.textContent = `Clock synced (${keep.length}/${rs.length})`;
      resolve();
    }
    once();
  });
}

// WebSocket
function openWS(){
  ws = new WebSocket('ws://' + location.hostname + ':81');
  ws.onopen = async ()=>{
    netEl.textContent = 'Syncing clock…';
    await syncClock(8);
  };
  ws.onmessage = (ev)=>{
    let d; try{ d=JSON.parse(ev.data); }catch{ return; }
    if (d.type==='ack' || d.type==='sync') return;
    if (paused) return;

    // push into ring buffers
    data.yaw[head]   = d.yaw;
    data.pitch[head] = d.pitch;
    data.roll[head]  = d.roll;
    data.ax[head]    = d.ax;
    data.ay[head]    = d.ay;
    data.az[head]    = d.az;
    head = (head + 1) % BUFFER;
  };
  ws.onclose = ()=> setTimeout(openWS, 800);
}
openWS();

// Plotting
function getRange(kind){
  if (!autoscaleEl.checked) return FIXED[kind];
  // autoscale over visible buffer for enabled series of this kind
  let lo= Infinity, hi= -Infinity;
  series.forEach(s=>{
    if (s.kind!==kind || !s.enabled) return;
    const arr = data[s.key];
    for (let i=0;i<BUFFER;i++){
      const v = arr[i];
      if (v==null) continue;
      if (v<lo) lo=v; if (v>hi) hi=v;
    }
  });
  if (lo===Infinity) return FIXED[kind];
  if (lo===hi){ lo-=1; hi+=1; }
  // add 10% headroom
  const pad = (hi-lo)*0.1;
  return [lo-pad, hi+pad];
}

function drawGrid(x, y, w, h, ylo, yhi, label){
  ctx.save();
  ctx.translate(x,y);
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  // axes
  for (let i=0;i<=5;i++){
    const yy = h*i/5;
    ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke();
  }
  ctx.fillStyle = '#999';
  ctx.font = '12px ui-monospace,monospace';
  ctx.fillText(`${label} [${ylo.toFixed(1)}..${yhi.toFixed(1)}]`, 8, 14);
  ctx.restore();
}

function mapY(val, ylo, yhi, y, h){
  const t = (val - ylo)/(yhi - ylo);
  return y + (1 - t)*h;
}

function drawSeries(arr, color, x, y, w, h, ylo, yhi){
  ctx.beginPath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  // iterate in time order: head..end, then 0..head-1
  let drew=false;
  const step = w / (BUFFER-1);
  let idx = head, px = x, first = true;
  for (let i=0;i<BUFFER;i++){
    const v = arr[idx];
    const py = (v==null) ? null : mapY(v, ylo, yhi, y, h);
    if (py!=null){
      if (first){ ctx.moveTo(px, py); first=false; }
      else ctx.lineTo(px, py);
      drew = true;
    } else {
      // lift pen on gaps
      first = true;
    }
    px += step;
    idx = (idx+1) % BUFFER;
  }
  if (drew) ctx.stroke();
}

function render(){
  ctx.clearRect(0,0,cvs.width,cvs.height);

  // Split canvas into two rows: angles (top), accel (bottom)
  const pad = 12;
  const w = cvs.width - pad*2;
  const h = cvs.height - pad*3;
  const rowH = (h/2) - pad;

  // ANGLES
  const [angLo,angHi] = getRange('ang');
  drawGrid(pad, pad, w, rowH, angLo, angHi, 'angles (deg)');
  series.filter(s=>s.kind==='ang' && s.enabled).forEach(s=>{
    drawSeries(data[s.key], s.color, pad, pad, w, rowH, angLo, angHi);
  });

  // ACCEL
  const [accLo,accHi] = getRange('acc');
  drawGrid(pad, pad*2+rowH, w, rowH, accLo, accHi, 'accel (m/s^2)');
  series.filter(s=>s.kind==='acc' && s.enabled).forEach(s=>{
    drawSeries(data[s.key], s.color, pad, pad*2+rowH, w, rowH, accLo, accHi);
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
)HTML";

// ---------- Wi-Fi / OTA ----------
static void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(SECRET_WIFI_SSID, SECRET_WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) { delay(200); Serial.print("."); }
  Serial.print("\nWiFi: "); Serial.println(WiFi.localIP());
}
static void setupOTA() {
  ArduinoOTA.setHostname(SECRET_OTA_HOSTNAME);
  if (SECRET_OTA_PASS_HASH && strlen(SECRET_OTA_PASS_HASH)==64) {
    ArduinoOTA.setPasswordHash(SECRET_OTA_PASS_HASH);
  }
  ArduinoOTA.begin();
  Serial.println("OTA ready");
}

// ---------- Logging ----------
void openLog(const char* name) {
  if (logFile) logFile.close();
  strncpy(currentLogName, name, sizeof(currentLogName));
  logFile = LittleFS.open(currentLogName, FILE_WRITE);
  if (logFile && logFile.size()==0) {
    logFile.println("t_ms,yaw,pitch,roll,ax,ay,az,event,note");
  }
}
void rotateLog() {
  static uint16_t idx = 1;
  char buf[48];
  snprintf(buf, sizeof(buf), "/imu_log_%u.csv", idx++);
  openLog(buf);
  Serial.printf("New session: %s\n", buf);
}

// ---------- HTTP ----------
void handleRoot() {
  http.setContentLength(strlen_P(PAGE_INDEX));
  http.sendHeader("Content-Type", "text/html; charset=utf-8");
  http.send(200, "text/html", "");
  http.sendContent_P(PAGE_INDEX);
}
void handleDownload() {
  if (!LittleFS.exists(currentLogName)) { http.send(404, "text/plain", "log not found"); return; }
  File f = LittleFS.open(currentLogName, FILE_READ);
  http.streamFile(f, "text/csv");
  f.close();
}

// ---------- WebSocket ----------
void wsEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t len) {
  if (type == WStype_TEXT) {
    String msg((char*)payload, len);

    // time sync request
    if (msg.indexOf("\"type\":\"sync\"") >= 0) {
      double t0 = 0;
      int k = msg.indexOf("\"t0\":");
      if (k >= 0) {
        int s = k + 5;
        int e = msg.indexOf(",", s);
        if (e < 0) e = msg.indexOf("}", s);
        if (e > s) t0 = msg.substring(s, e).toDouble();
      }
      char js[96];
      snprintf(js, sizeof(js), "{\"type\":\"sync\",\"t0\":%.3f,\"t1_ms\":%lu}",
               t0, (unsigned long)dev_now_ms());
      ws.sendTXT(num, js);
      return;
    }

    // rotate command
    if (msg.indexOf("\"type\":\"rotate\"") >= 0) {
      rotateLog();
      ws.sendTXT(num, "{\"type\":\"ack\",\"cmd\":\"rotate\"}");
      return;
    }

    // event with optional note (append to CSV)
    String kind = "", note = "";
    int k2 = msg.indexOf("\"kind\":\""); if (k2>=0){ int s=k2+8; int e=msg.indexOf("\"",s); kind=msg.substring(s,e); }
    int n = msg.indexOf("\"note\":\""); if (n>=0){ int s=n+8; int e=msg.indexOf("\"",s); note=msg.substring(s,e); note.replace(",", " "); }
    uint32_t t = millis();
    if (logFile) logFile.printf("%lu,,,,,,,%s,%s\n", (unsigned long)t, kind.c_str(), note.c_str());
    ws.sendTXT(num, "{\"type\":\"ack\",\"cmd\":\"event\"}");
  }
}

// ---------- Setup ----------
void setup() {
  Serial.begin(115200);
  delay(100);

  if (!LittleFS.begin(true)) {
    Serial.println("LittleFS mount failed");
  }
  openLog(currentLogName);     // /imu_log.csv (default)

  connectWiFi();
  setupOTA();

  // BNO085 one-wire UART
  Serial1.begin(115200, SERIAL_8N1, BNO_RX_PIN, BNO_TX_PIN);
  if (!rvc.begin(&Serial1)) Serial.println("BNO085 RVC init failed!");
  else Serial.println("BNO085 RVC ready.");

  // HTTP + WS
  http.on("/", handleRoot);
  http.on("/download", handleDownload);
  http.begin();

  ws.begin();
  ws.onEvent(wsEvent);

  Serial.println("Open http://<ESP-IP>/ in your phone browser");
  Serial.println("WebSocket port: 81");
}

// ---------- Loop ----------
void loop() {
#if DIAG_TIMING
  uint32_t now = dev_now_us();
  Serial.printf("DeltaRead_us=%lu DeltaSend_us=%lu\n", now - lastReadMicros, now - lastSendMicros);
  lastReadMicros = now;
#endif

  ArduinoOTA.handle();
  http.handleClient();
  ws.loop();

  // Read IMU → stream & log
  static uint32_t lastFlush = 0;
  static uint32_t lastSend  = 0;

  BNO08x_RVC_Data d;
  if (rvc.read(&d)) {
    const uint32_t tr_us = dev_now_us();  // device time at read (us)
    const uint32_t t_ms  = dev_now_ms();  // device time at read (ms)

    // --- throttle WS to ~60 Hz (smoother, less jitter) ---
    if (t_ms - lastSend >= 16) {  // 16 ms ≈ 60 fps
      lastSend = t_ms;

      // Timestamp right before send
      const uint32_t ts_us = dev_now_us();
      const uint32_t thisSeq = ++seqNo;

      // compact JSON for WS UI (with timing; UI doesn’t use here, but harmless)
      char js[196];
      snprintf(js, sizeof(js),
        "{\"type\":\"data\",\"seq\":%lu,\"t\":%lu,\"tr_us\":%lu,\"ts_us\":%lu,"
        "\"yaw\":%.2f,\"pitch\":%.2f,\"roll\":%.2f,\"ax\":%.3f,\"ay\":%.3f,\"az\":%.3f}",
        (unsigned long)thisSeq, (unsigned long)t_ms,
        (unsigned long)tr_us, (unsigned long)ts_us,
        d.yaw, d.pitch, d.roll, d.x_accel, d.y_accel, d.z_accel);
      ws.broadcastTXT(js);

#if ENABLE_LOGGING
      if (logFile) {
        logFile.printf("%lu,%.6f,%.6f,%.6f,%.6f,%.6f,%.6f,,\n",
          (unsigned long)t_ms, d.yaw, d.pitch, d.roll, d.x_accel, d.y_accel, d.z_accel);

        // flush once per second instead of every line
        if (t_ms - lastFlush >= 1000) {
          lastFlush = t_ms;
          logFile.flush();
        }
      }
#endif
    }
  }
}
